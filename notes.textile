h2. Switch

Need something to allow switching 2 (or more) items in the array that will adjust the iteration index.

  Example:

bc.. battingOrder = IterableArray.new [ 'bob', 'joe', 'jenna', 'will' ]
    ...
    battingOrder.iterationMethod do |item, index|
    # Within an iteration block...
    # Assume the current index is 1 and that the current item is 'joe'...
    # battingOrder[1], battingOrder[2] = battingOrder[2], battingOrder[1]
    # The preceding line would result that:
    # battingOrder == [ 'bob', 'jenna', 'joe', 'will' ]
    # But I don't think that there's any way that I could set it up so that
    # the next item yielded would be 'will' rather than 'joe' again.
    # Since I think that this is something one might want to be able to do,
    # I may add a method called switch. Like so:

    switch_indices( 1, 2 )

    # However, I won't do it until I have most of the Array instance methods
    # implemented.
    ...
  end
  
h2. Break/halt

Using break within an iteration block on an IterableArray will prevent the IterableArray iteration method from cleaning up / tearing down its index-aware methods and structure. In the case of nested iteration, the index-tracking could be broken. As a result, I think I'll need to provide a custom catch/throw mechanism similar to the @:halt@ method used in Sinatra.

h2. methods that iterate _and_ modify

(Example: @:delete_if@). Will implement after finishing all the easier methods. It might be possible by getting a binding in the original, parent IterableArray and passing that single binding on to all its descendants.

h2. :[]=

It might be the case that I don't need to provide any special handling for @:[]=@ since it never deletes and will only affect the size of a non-empty array by appending onto the end. I'll be keeping an eye out for any cases where it would be necessary to implement it specially rather than just delegate it to @@array@.

h2. :sort!

This'll work...
Assume x is the current index object in an array. We'll first run a test to see if it's unique in the array. If it's unique, then we can just find out where it ended up after the sort and then re-adjust the index accordingly. If it's not unique, we'll find out if it's the first/second/.../nth/.../last of it's kind in the array. And then after the sort, we'll set current index to that position of the items that are the same as x.
